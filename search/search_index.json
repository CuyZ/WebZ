{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"WebZ \u26a0\ufe0f This project is in the experimental phase. The API may change any time. WebZ is a library that aims to abstract calls to different WebServices (in HTTP or SOAP). It automatically handles caching, events and parsing results to an array. $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withCache ( new SomeCacheStore ()) -> withEventDispatcher ( new SomeEventsDispatcher ()) -> build (); // Synchronous $foo = $bus -> call ( new GetFooWebService ( 123 )); // Asynchronous $promises = $bus -> callAsync ( new GetFooWebService ( 123 ), new GetFooWebService ( 456 ), ); foreach ( $promises as $promise ) { $foo = $promise -> wait (); }","title":"Introduction"},{"location":"#webz","text":"\u26a0\ufe0f This project is in the experimental phase. The API may change any time. WebZ is a library that aims to abstract calls to different WebServices (in HTTP or SOAP). It automatically handles caching, events and parsing results to an array. $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withCache ( new SomeCacheStore ()) -> withEventDispatcher ( new SomeEventsDispatcher ()) -> build (); // Synchronous $foo = $bus -> call ( new GetFooWebService ( 123 )); // Asynchronous $promises = $bus -> callAsync ( new GetFooWebService ( 123 ), new GetFooWebService ( 456 ), ); foreach ( $promises as $promise ) { $foo = $promise -> wait (); }","title":"WebZ"},{"location":"getting-started/","text":"Getting Started Installation $ composer req cuyz/webz To use the SOAP transport you need the soap PHP extension. To install it see SOAP Installation . Usage To implement a WebService all you need is a class extending \\CuyZ\\WebZ\\Core\\WebService . use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService { protected function payload () : object { // The payload depends on the transport (SOAP or HTTP) } public function parse ( array $data ) : object { // Here you have access to the result as an array // and can parse it to any object. } }","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"$ composer req cuyz/webz To use the SOAP transport you need the soap PHP extension. To install it see SOAP Installation .","title":"Installation"},{"location":"getting-started/#usage","text":"To implement a WebService all you need is a class extending \\CuyZ\\WebZ\\Core\\WebService . use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService { protected function payload () : object { // The payload depends on the transport (SOAP or HTTP) } public function parse ( array $data ) : object { // Here you have access to the result as an array // and can parse it to any object. } }","title":"Usage"},{"location":"why/","text":"Why? Imagine you have to fetch some data from an external WebService. You need to instanciate some client, make the call, parse the response, cache it, handle exceptions, manually manage concurrent calls, log, etc. All this code could be repeated in multiple places and projects: use GuzzleHttp\\Client ; $client = new Client (); $response = $client -> request ( 'GET' , 'https://api.example.com/get-data' ); $data = json_decode ( $response -> getBody () -> getContents (), true , 512 , JSON_THROW_ON_ERROR ); // Here you might have to handle the cache, exceptions, etc echo $data [ 'foo' ]; Exemple With WebZ you can abstract all this. Let say we want to fetch this data object: namespace Acme ; class Place { private string $name ; public function __construct ( string $name ) { $this -> name = $name ; } public function name () : string { return $this -> name ; } } HTTP It can be fetched from an HTTP request: use Acme\\Place ; use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Http\\Payload\\HttpPayload ; class GetPlace extends WebService { private int $id ; public function __construct ( int $id ) { $this -> id = $id ; } protected function payload () : HttpPayload { return HttpPayload :: request ( 'GET' , 'https://my-api.com/v1/place/' . $this -> id ); } public function parse ( array $data ) : Place { return new Place ( $data [ 'name' ]); } } SOAP Or from SOAP: use Acme\\Place ; use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Soap\\SoapPayload ; class GetPlace extends WebService { private int $id ; public function __construct ( int $id ) { $this -> id = $id ; } protected function payload () : SoapPayload { return SoapPayload :: forWsdl ( 'https://my-example.com/api/wsdl.xml' ) -> withAction ( 'getPlace' ) -> withArguments ([ $this -> id ]); } public function parse ( array $data ) : Place { return new Place ( $data [ 'name' ]); } } The call You then call any WebService via the Bus and a compatible transport will call the WebService: use Acme\\Place ; use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> build (); $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name (); // You can also call multiple webservices in concurrency $promises = $bus -> callAsync ( new GetPlace ( 123 ), new GetPlace ( 456 ), ); foreach ( $promises as $promise ) { /** @var Place $place */ $place = $promise -> wait (); echo $place -> name (); } In the end the GetPlace class looks transport agnostic and can be reused anywhere in your project. And if the WebService changes anything (url, parameters, protocol, etc) you only have one place to update in your code.","title":"Why?"},{"location":"why/#why","text":"Imagine you have to fetch some data from an external WebService. You need to instanciate some client, make the call, parse the response, cache it, handle exceptions, manually manage concurrent calls, log, etc. All this code could be repeated in multiple places and projects: use GuzzleHttp\\Client ; $client = new Client (); $response = $client -> request ( 'GET' , 'https://api.example.com/get-data' ); $data = json_decode ( $response -> getBody () -> getContents (), true , 512 , JSON_THROW_ON_ERROR ); // Here you might have to handle the cache, exceptions, etc echo $data [ 'foo' ];","title":"Why?"},{"location":"why/#exemple","text":"With WebZ you can abstract all this. Let say we want to fetch this data object: namespace Acme ; class Place { private string $name ; public function __construct ( string $name ) { $this -> name = $name ; } public function name () : string { return $this -> name ; } }","title":"Exemple"},{"location":"why/#http","text":"It can be fetched from an HTTP request: use Acme\\Place ; use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Http\\Payload\\HttpPayload ; class GetPlace extends WebService { private int $id ; public function __construct ( int $id ) { $this -> id = $id ; } protected function payload () : HttpPayload { return HttpPayload :: request ( 'GET' , 'https://my-api.com/v1/place/' . $this -> id ); } public function parse ( array $data ) : Place { return new Place ( $data [ 'name' ]); } }","title":"HTTP"},{"location":"why/#soap","text":"Or from SOAP: use Acme\\Place ; use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Soap\\SoapPayload ; class GetPlace extends WebService { private int $id ; public function __construct ( int $id ) { $this -> id = $id ; } protected function payload () : SoapPayload { return SoapPayload :: forWsdl ( 'https://my-example.com/api/wsdl.xml' ) -> withAction ( 'getPlace' ) -> withArguments ([ $this -> id ]); } public function parse ( array $data ) : Place { return new Place ( $data [ 'name' ]); } }","title":"SOAP"},{"location":"why/#the-call","text":"You then call any WebService via the Bus and a compatible transport will call the WebService: use Acme\\Place ; use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> build (); $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name (); // You can also call multiple webservices in concurrency $promises = $bus -> callAsync ( new GetPlace ( 123 ), new GetPlace ( 456 ), ); foreach ( $promises as $promise ) { /** @var Place $place */ $place = $promise -> wait (); echo $place -> name (); } In the end the GetPlace class looks transport agnostic and can be reused anywhere in your project. And if the WebService changes anything (url, parameters, protocol, etc) you only have one place to update in your code.","title":"The call"},{"location":"advanced/async-transport/","text":"Async transport A transport can implement the \\CuyZ\\WebZ\\Core\\Transport\\AsyncTransport interface to send payloads asynchronously. use CuyZ\\WebZ\\Core\\Result\\RawResult ; use CuyZ\\WebZ\\Core\\Transport\\AsyncTransport ; use GuzzleHttp\\Promise\\PromiseInterface ; class MyTransport implements AsyncTransport { public function send ( object $payload ) : ? RawResult { return $this -> sendAsync ( $payload , null ) -> wait (); } public function sendAsync ( object $payload , ? string $asyncCallHash ) : ? PromiseInterface { // If the payload is not supported by this transport // it must return null if ( ! $payload instanceof MyPayload ) { return null ; } return $this -> someService -> call ( $payload -> someMethod ( ... )) // The promise must return an instance of RawResult -> then ( fn ( SomResponse $res ) => RawResult :: ok ( $res -> toArray ())); } }","title":"Async Transport"},{"location":"advanced/async-transport/#async-transport","text":"A transport can implement the \\CuyZ\\WebZ\\Core\\Transport\\AsyncTransport interface to send payloads asynchronously. use CuyZ\\WebZ\\Core\\Result\\RawResult ; use CuyZ\\WebZ\\Core\\Transport\\AsyncTransport ; use GuzzleHttp\\Promise\\PromiseInterface ; class MyTransport implements AsyncTransport { public function send ( object $payload ) : ? RawResult { return $this -> sendAsync ( $payload , null ) -> wait (); } public function sendAsync ( object $payload , ? string $asyncCallHash ) : ? PromiseInterface { // If the payload is not supported by this transport // it must return null if ( ! $payload instanceof MyPayload ) { return null ; } return $this -> someService -> call ( $payload -> someMethod ( ... )) // The promise must return an instance of RawResult -> then ( fn ( SomResponse $res ) => RawResult :: ok ( $res -> toArray ())); } }","title":"Async transport"},{"location":"advanced/contribute/","text":"Contributing To setup the dev you need to clone the repo and then run: $ make install To run the full test suite: $ make test To run only unit tests: $ make test-unit","title":"Contribute"},{"location":"advanced/contribute/#contributing","text":"To setup the dev you need to clone the repo and then run: $ make install To run the full test suite: $ make test To run only unit tests: $ make test-unit","title":"Contributing"},{"location":"advanced/transport/","text":"Transport WebZ comes with an HTTP and a SOAP transports \u2014 you may add your own if needed. A transport is a class that implements \\CuyZ\\WebZ\\Core\\Transport\\Transport . The send method accepts an object payload that you need to test for compatibility. use CuyZ\\WebZ\\Core\\Result\\RawResult ; use CuyZ\\WebZ\\Core\\Transport\\Transport ; class MyTransport implements Transport { public function send ( object $payload ) : ? RawResult { // If the payload is not supported by this transport // it must return null if ( ! $payload instanceof MyPayload ) { return null ; } try { $raw = $this -> someService -> call ( $payload -> someMethod ( ... )); // For a successful call // $raw must be an array return RawResult :: ok ( $raw ); } catch ( \\Exception $e ) { // For a failed call return RawResult :: err ( $e ); } } } You then need to register it in the Bus: $bus = WebServiceBus :: builder () // The order is important, transports are tried in order // and the first compatible one is called. -> withTransport ( new MyTransport ()) -> withTransport ( ... ) -> build (); $foo = $bus -> call ( new GetFooWebService ( 123 ));","title":"Transport"},{"location":"advanced/transport/#transport","text":"WebZ comes with an HTTP and a SOAP transports \u2014 you may add your own if needed. A transport is a class that implements \\CuyZ\\WebZ\\Core\\Transport\\Transport . The send method accepts an object payload that you need to test for compatibility. use CuyZ\\WebZ\\Core\\Result\\RawResult ; use CuyZ\\WebZ\\Core\\Transport\\Transport ; class MyTransport implements Transport { public function send ( object $payload ) : ? RawResult { // If the payload is not supported by this transport // it must return null if ( ! $payload instanceof MyPayload ) { return null ; } try { $raw = $this -> someService -> call ( $payload -> someMethod ( ... )); // For a successful call // $raw must be an array return RawResult :: ok ( $raw ); } catch ( \\Exception $e ) { // For a failed call return RawResult :: err ( $e ); } } } You then need to register it in the Bus: $bus = WebServiceBus :: builder () // The order is important, transports are tried in order // and the first compatible one is called. -> withTransport ( new MyTransport ()) -> withTransport ( ... ) -> build (); $foo = $bus -> call ( new GetFooWebService ( 123 ));","title":"Transport"},{"location":"services/cache/","text":"Cache To use caching your WebService needs to implement \\CuyZ\\WebZ\\Core\\Cache\\WithCache : use CuyZ\\WebZ\\Core\\Cache\\WithCache ; use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService implements WithCache { public function cacheLifetime () : int { // TTL is in seconds // If the TTL is lower or equal to 0, the cache is disabled return 60 ; } protected function payload () : object { ... } public function parse ( array $data ) : object { ... } } You also need to configure a cache store implementing PSR-16 (Simple Cache). You can find one on Packagist . For example with symfony/cache : use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use Symfony\\Component\\Cache\\Adapter\\ArrayAdapter ; use Symfony\\Component\\Cache\\Psr16Cache ; $pool = new Psr16Cache ( new ArrayAdapter ()); $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withCache ( $pool ) -> build (); $place = $bus -> call ( new GetPlace ( 123 )); // This call comes from the cache $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name ();","title":"Cache"},{"location":"services/cache/#cache","text":"To use caching your WebService needs to implement \\CuyZ\\WebZ\\Core\\Cache\\WithCache : use CuyZ\\WebZ\\Core\\Cache\\WithCache ; use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService implements WithCache { public function cacheLifetime () : int { // TTL is in seconds // If the TTL is lower or equal to 0, the cache is disabled return 60 ; } protected function payload () : object { ... } public function parse ( array $data ) : object { ... } } You also need to configure a cache store implementing PSR-16 (Simple Cache). You can find one on Packagist . For example with symfony/cache : use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use Symfony\\Component\\Cache\\Adapter\\ArrayAdapter ; use Symfony\\Component\\Cache\\Psr16Cache ; $pool = new Psr16Cache ( new ArrayAdapter ()); $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withCache ( $pool ) -> build (); $place = $bus -> call ( new GetPlace ( 123 )); // This call comes from the cache $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name ();","title":"Cache"},{"location":"services/events/","text":"Events You can subscribe to some events sent from the Bus. It can be used to add logging for example. You will need to install an event library that implements PSR-14 (Event Dispatcher). You can find one on Packagist . For example with symfony/event-dispatcher : use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Core\\Event\\BeforeCallEvent ; use CuyZ\\WebZ\\Core\\Event\\FailedCallEvent ; use CuyZ\\WebZ\\Core\\Event\\SuccessfulCallEvent ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use Symfony\\Component\\EventDispatcher\\EventDispatcher ; $dispatcher = new EventDispatcher (); $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withEventDispatcher ( $dispatcher ) -> build (); $dispatcher -> addListener ( BeforeCallEvent :: class , function ( BeforeCallEvent $event ) { // This event is dispatched before a WebService is called } ); $dispatcher -> addListener ( FailedCallEvent :: class , function ( FailedCallEvent $event ) { // This event is dispatched when the call failed } ); $dispatcher -> addListener ( SuccessfulCallEvent :: class , function ( SuccessfulCallEvent $event ) { // This event is dispatched when the call had no error } ); $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name ();","title":"Events"},{"location":"services/events/#events","text":"You can subscribe to some events sent from the Bus. It can be used to add logging for example. You will need to install an event library that implements PSR-14 (Event Dispatcher). You can find one on Packagist . For example with symfony/event-dispatcher : use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Core\\Event\\BeforeCallEvent ; use CuyZ\\WebZ\\Core\\Event\\FailedCallEvent ; use CuyZ\\WebZ\\Core\\Event\\SuccessfulCallEvent ; use CuyZ\\WebZ\\Http\\HttpTransport ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use Symfony\\Component\\EventDispatcher\\EventDispatcher ; $dispatcher = new EventDispatcher (); $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()) -> withTransport ( new SoapTransport ()) -> withEventDispatcher ( $dispatcher ) -> build (); $dispatcher -> addListener ( BeforeCallEvent :: class , function ( BeforeCallEvent $event ) { // This event is dispatched before a WebService is called } ); $dispatcher -> addListener ( FailedCallEvent :: class , function ( FailedCallEvent $event ) { // This event is dispatched when the call failed } ); $dispatcher -> addListener ( SuccessfulCallEvent :: class , function ( SuccessfulCallEvent $event ) { // This event is dispatched when the call had no error } ); $place = $bus -> call ( new GetPlace ( 123 )); echo $place -> name ();","title":"Events"},{"location":"services/exceptions/","text":"Exceptions By default Exception are thrown as-is. You can handle exceptions in any WebService by implementing \\CuyZ\\WebZ\\Core\\Exception\\HandlesExceptions : use CuyZ\\WebZ\\Core\\Exception\\HandlesExceptions ; use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService implements HandlesExceptions { public function onException ( Exception $e ) : void { throw new MyCustomException ( $e ); } protected function payload () : object { ... } public function parse ( array $data ) : object { ... } }","title":"Exceptions"},{"location":"services/exceptions/#exceptions","text":"By default Exception are thrown as-is. You can handle exceptions in any WebService by implementing \\CuyZ\\WebZ\\Core\\Exception\\HandlesExceptions : use CuyZ\\WebZ\\Core\\Exception\\HandlesExceptions ; use CuyZ\\WebZ\\Core\\WebService ; class GetPlace extends WebService implements HandlesExceptions { public function onException ( Exception $e ) : void { throw new MyCustomException ( $e ); } protected function payload () : object { ... } public function parse ( array $data ) : object { ... } }","title":"Exceptions"},{"location":"transports/http/","text":"HTTP The HTTP transport uses Guzzle internally. Activation The transport needs to be activated using the builder: use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ()); Payload To use the transport in a webservice you need to implement the payload method in you webservice class: use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Http\\Payload\\HttpPayload ; final class MyHttpWebService extends WebService { protected function payload () : HttpPayload { return HttpPayload :: request ( 'GET' , 'https://my-api.com/v1/foo' ); } // Other methods... }","title":"HTTP"},{"location":"transports/http/#http","text":"The HTTP transport uses Guzzle internally.","title":"HTTP"},{"location":"transports/http/#activation","text":"The transport needs to be activated using the builder: use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Http\\HttpTransport ; $bus = WebServiceBus :: builder () -> withTransport ( new HttpTransport ());","title":"Activation"},{"location":"transports/http/#payload","text":"To use the transport in a webservice you need to implement the payload method in you webservice class: use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Http\\Payload\\HttpPayload ; final class MyHttpWebService extends WebService { protected function payload () : HttpPayload { return HttpPayload :: request ( 'GET' , 'https://my-api.com/v1/foo' ); } // Other methods... }","title":"Payload"},{"location":"transports/soap/","text":"SOAP To use the SOAP transport you need the soap PHP extension. To install it see SOAP Installation . Activation The transport needs to be activated using the builder: use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use GuzzleHttp\\Client ; $bus = WebServiceBus :: builder () -> withTransport ( new SoapTransport ()); Payload To use the transport in a webservice you need to implement the payload method in you webservice class: use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Soap\\SoapPayload ; final class MySoapWebService extends WebService { protected function payload () : SoapPayload { return SoapPayload :: forWsdl ( 'https://my-example.com/api/wsdl.xml' ) -> withAction ( 'getFoo' ); } // Other methods... }","title":"SOAP"},{"location":"transports/soap/#soap","text":"To use the SOAP transport you need the soap PHP extension. To install it see SOAP Installation .","title":"SOAP"},{"location":"transports/soap/#activation","text":"The transport needs to be activated using the builder: use CuyZ\\WebZ\\Core\\Bus\\WebServiceBus ; use CuyZ\\WebZ\\Soap\\SoapTransport ; use GuzzleHttp\\Client ; $bus = WebServiceBus :: builder () -> withTransport ( new SoapTransport ());","title":"Activation"},{"location":"transports/soap/#payload","text":"To use the transport in a webservice you need to implement the payload method in you webservice class: use CuyZ\\WebZ\\Core\\WebService ; use CuyZ\\WebZ\\Soap\\SoapPayload ; final class MySoapWebService extends WebService { protected function payload () : SoapPayload { return SoapPayload :: forWsdl ( 'https://my-example.com/api/wsdl.xml' ) -> withAction ( 'getFoo' ); } // Other methods... }","title":"Payload"}]}